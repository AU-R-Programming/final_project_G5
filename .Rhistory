my_lm = function(response, covariates, alpha = 0.05) {
# Make sure data formats are appropriate
response <- as.vector(response)
covariates <- as.matrix(covariates)
# Define parameters
n <- length(response)
p <- dim(covariates)[2]
df <- n - p
# Estimate beta through Eq. (6.1)
beta.hat <- solve(t(covariates)%*%covariates)%*%t(covariates)%*%response
# Estimate of the residual variance (sigma2) from Eq. (6.3)
# Compute residuals
resid <- response - covariates%*%as.matrix(beta.hat)
sigma2.hat <- (1/df)*t(resid)%*%resid
# Estimate of the variance of the estimated beta from Eq. (6.2)
var.beta <- sigma2.hat*solve(t(covariates)%*%covariates)
# Estimate of the confidence interval based on alpha
quant <- 1 - alpha/2
ci.beta <- c(beta.hat - qnorm(p = quant)*sqrt(var.beta), beta.hat +
qnorm(p = quant)*sqrt(var.beta))
# Return all estimated values
return(list(beta = beta.hat, sigma2 = sigma2.hat,
variance_beta = var.beta, ci = ci.beta))
}
class_data <- read.csv("forestfires.csv")
class_data
class_data <- read.csv("forestfires.csv")
beta_hat_func = function(y, x, beta){
return(t(y-x*beta)*(y-x*beta))
}
y<- class_data[,"ISI"]
x<- class_data[,c("temp","wind")]
X<- cbind(1,x)
X
beta_zero<- c(mean(y), cov(y,x[,2])/var(x[,2]), cov(y,x[,3])/var(x[,3]) )
class_data <- read.csv("forestfires.csv")
#Function to minimize to achieve beta estimate
beta_hat_func = function(y, x, beta){
return(t(y-x*beta)*(y-x*beta))
}
#Test data
y<- class_data[,"ISI"]
x<- class_data[,c("temp","wind")]
X<- cbind(1,x)
#initial beta
beta_zero<- c(mean(y), cov(y,x[,2])/var(x[,2]), cov(y,x[,3])/var(x[,3]) )
dimx
dim(x)
x
class_data <- read.csv("forestfires.csv")
#Function to minimize to achieve beta estimate
beta_hat_func = function(y, x, beta){
return(t(y-x*beta)*(y-x*beta))
}
#Test data
y<- class_data[,"ISI"]
x<- class_data[,c("temp","wind")]
x<- cbind(1,x)
#initial beta
beta_zero<- c(mean(y), cov(y,x[,2])/var(x[,2]), cov(y,x[,3])/var(x[,3]) )
beta_zero
beta_hat_func(y,x,beta_zero)
class_data <- read.csv("forestfires.csv")
#Function to minimize to achieve beta estimate
beta_hat_func = function(y, x, beta){
return(t(y-x%*%beta)%*%(y-x%*%beta))
}
#Test data
y<- class_data[,"ISI"]
x<- class_data[,c("temp","wind")]
x<- cbind(1,x)
#initial beta
beta_zero<- c(mean(y), cov(y,x[,2])/var(x[,2]), cov(y,x[,3])/var(x[,3]) )
#make sure beta hat function works for y x and betazero
beta_hat_func(y,x,beta_zero)
class_data <- read.csv("forestfires.csv")
#Function to minimize to achieve beta estimate
beta_hat_func = function(y, x, beta){
return(t(y-x*beta)%*%(y-x*beta))
}
#Test data
y<- class_data[,"ISI"]
x<- class_data[,c("temp","wind")]
x<- cbind(1,x)
#initial beta
beta_zero<- c(mean(y), cov(y,x[,2])/var(x[,2]), cov(y,x[,3])/var(x[,3]) )
#make sure beta hat function works for y x and betazero
beta_hat_func(y,x,beta_zero)
class_data <- read.csv("forestfires.csv")
#Function to minimize to achieve beta estimate
beta_hat_func = function(y, x, beta){
return(as.matrix(t(y-x*beta)%*%(y-x*beta))
}
#Test data
y<- class_data[,"ISI"]
x<- class_data[,c("temp","wind")]
x<- cbind(1,x)
#initial beta
beta_zero<- c(mean(y), cov(y,x[,2])/var(x[,2]), cov(y,x[,3])/var(x[,3]) )
#make sure beta hat function works for y x and betazero
beta_hat_func(y,x,beta_zero)
class_data <- read.csv("forestfires.csv")
#Function to minimize to achieve beta estimate
beta_hat_func = function(y, x, beta){
return((t(y-as.matrix(x)*beta))%*%(y-as.matrix(x)*beta)
}
#Test data
y<- class_data[,"ISI"]
x<- class_data[,c("temp","wind")]
x<- cbind(1,x)
#initial beta
beta_zero<- c(mean(y), cov(y,x[,2])/var(x[,2]), cov(y,x[,3])/var(x[,3]) )
#make sure beta hat function works for y x and betazero
beta_hat_func(y,x,beta_zero)
as.matrix(x)
y-as.matrix(x)*beta
y-as.matrix(x)*beta_zero
t(y-as.matrix(x)*beta_zero))%*%(y-as.matrix(x)*beta_zero)
class_data <- read.csv("forestfires.csv")
#Function to minimize to achieve beta estimate
beta_hat_func = function(y, x, beta){
return((t(y-as.matrix(x)*beta)%*%(y-as.matrix(x)*beta))
}
#Test data
y<- class_data[,"ISI"]
x<- class_data[,c("temp","wind")]
x<- cbind(1,x)
#initial beta
beta_zero<- c(mean(y), cov(y,x[,2])/var(x[,2]), cov(y,x[,3])/var(x[,3]) )
#make sure beta hat function works for y x and betazero
beta_hat_func(y,x,beta_zero)
class_data <- read.csv("forestfires.csv")
#Function to minimize to achieve beta estimate
beta_hat_func = function(y, x, beta){
return((t(y-as.matrix(x)%*%beta)%*%(y-as.matrix(x)%*%beta))
}
#Test data
y<- class_data[,"ISI"]
x<- class_data[,c("temp","wind")]
x<- cbind(1,x)
#initial beta
beta_zero<- c(mean(y), cov(y,x[,2])/var(x[,2]), cov(y,x[,3])/var(x[,3]) )
#make sure beta hat function works for y x and betazero
beta_hat_func(y,x,beta_zero)
beta_hat_func = function(y, x, beta){
return((t(y-as.matrix(x)%*%beta)%*%(y-as.matrix(x)%*%beta))
}
beta_hat_func = function(y, x, beta){
return((t(y-as.matrix(x)%*%beta))%*%(y-as.matrix(x)%*%beta))
}
class_data <- read.csv("forestfires.csv")
#Function to minimize to achieve beta estimate
beta_hat_func = function(y, x, beta){
return((t(y-as.matrix(x)%*%beta))%*%(y-as.matrix(x)%*%beta))
}
#Test data
y<- class_data[,"ISI"]
x<- class_data[,c("temp","wind")]
x<- cbind(1,x)
#initial beta
beta_zero<- c(mean(y), cov(y,x[,2])/var(x[,2]), cov(y,x[,3])/var(x[,3]) )
#make sure beta hat function works for y x and betazero
beta_hat_func(y,x,beta_zero)
class_data <- read.csv("forestfires.csv")
#Function to minimize to achieve beta estimate
beta_hat_func = function(y, x, beta){
return((t(y-as.matrix(x)%*%beta))%*%(y-as.matrix(x)%*%beta))
}
#Test data
y<- class_data[,"ISI"]
x<- class_data[,c("temp","wind")]
x<- cbind(1,x)
dim(x)
p<- dim(x)[2]
p
beta_zero<- NA
p<- dim(x)[2]
beta_zero[1] <- mean(y)
beta_zero
optim(beta_zero, function (z) beta_hat_func(y,x,z))
betahat_optimize<- optim(beta_zero, function (z) beta_hat_func(y,x,z))
betahat_optimize
class_data <- read.csv("forestfires.csv")
#Function to minimize to achieve beta estimate
beta_hat_func = function(y, x, beta){
return((t(y-as.matrix(x)%*%beta))%*%(y-as.matrix(x)%*%beta))
}
#Test data
y<- class_data[,"ISI"]
x<- class_data[,c("temp","wind")]
x<- cbind(1,x)
#initial beta_zero
beta_zero<- NA
p<- dim(x)[2]
beta_zero[1] <- mean(y)
#continuing to fill in beta_zero
for (i in 2:p) {
beta_zero[i]<- cov(y,x[,i])/var(x[,i])
}
#make sure beta hat function works for y x and betazero
beta_hat_func(y,x,beta_zero)
betahat_optimize<- optim(beta_zero, function (z) beta_hat_func(y,x,z))
betahat_optimize
beta_zero
lm(y~x)
x
lm(y~as.data.frame(x))
as.data.frame(x)
is(as.data.frame(x))
is(as.data.frame(as.matrix(x)))
unlist(x)
x[[1]]
x[[2]]
x<- class_data[,c("temp","wind")]
is(x)
head(x)
#Test data
y<- class_data[,"ISI"]
x<- class_data[,c("temp","wind")]
x<- cbind(1,x)
head(x)
is(x)
colnames(x)
lm(y~x)
y<- class_data[,"ISI"]
x<- class_data[,c("temp","wind")]
x<- cbind("intercept"=1,x)
x$temp
is(x$temp)
is(x$wind)
is(x$intercept)
#Test data
y<- class_data[,"ISI"]
x<- class_data[,c("temp","wind")]
x<- cbind("intercept"=1,x)
lm(y~x)
is(x)
lm(y~x$temp+x$wind)
```{r}
class_data <- read.csv("forestfires.csv")
#Function to minimize to achieve beta estimate
beta_hat_func = function(y, x, beta){
return((t(y-as.matrix(x)%*%beta))%*%(y-as.matrix(x)%*%beta))
}
#Test data
y<- class_data[,"ISI"]
x<- class_data[,c("temp","wind")]
x<- cbind(1,x)
#initial beta_zero
beta_zero<- NA
p<- dim(x)[2]
beta_zero[1] <- mean(y)
#continuing to fill in beta_zero
for (i in 2:p) {
beta_zero[i]<- cov(y,x[,i])/var(x[,i])
}
#make sure beta hat function works for y x and betazero
beta_hat_func(y,x,beta_zero)
betahat_optimize<- optim(beta_zero, function (z) beta_hat_func(y,x,z))
betahat_optimize
betahat_optimize<- optim(beta_zero, function (z) beta_hat_func(y,x,z))
betahat<- betahat_optimize $par
betahat
my_lm = function(response, covariates, alpha = 0.05) {
# Make sure data formats are appropriate
response <- as.vector(response)
covariates <- as.matrix(covariates)
# Define parameters
n <- length(response)
p <- dim(covariates)[2]
df <- n - p
# Estimate beta through optimization()
x= covariates
y= response
beta_zero<- NA
p<- dim(x)[2]
beta_zero[1] <- mean(y)
#continuing to fill in beta_zero
for (i in 2:p) {
beta_zero[i]<- cov(y,x[,i])/var(x[,i])
}
#make sure beta hat function works for y x and betazero
beta_hat_func(y,x,beta_zero)
betahat_optimize<- optim(beta_zero, function (z) beta_hat_func(y,x,z))
beta.hat<- betahat_optimize $par
# Estimate of the residual variance (sigma2) from Eq. (6.3)
# Compute residuals
resid <- response - covariates%*%as.matrix(beta.hat)
sigma2.hat <- (1/df)*t(resid)%*%resid
# Estimate of the variance of the estimated beta from Eq. (6.2)
var.beta <- sigma2.hat*solve(t(covariates)%*%covariates)
# Estimate of the confidence interval based on alpha
quant <- 1 - alpha/2
ci.beta <- c(beta.hat - qnorm(p = quant)*sqrt(var.beta), beta.hat +
qnorm(p = quant)*sqrt(var.beta))
# Return all estimated values
return(list(beta = beta.hat, sigma2 = sigma2.hat,
variance_beta = var.beta, ci = ci.beta))
}
my_lm(y,x)
x
response = y
covariates=x
response <- as.vector(response)
covariates <- as.matrix(covariates)
# Define parameters
n <- length(response)
p <- dim(covariates)[2]
df <- n - p
# Estimate beta through optimization()
x= covariates
y= response
beta_zero<- NA
p<- dim(x)[2]
beta_zero[1] <- mean(y)
#continuing to fill in beta_zero
for (i in 2:p) {
beta_zero[i]<- cov(y,x[,i])/var(x[,i])
}
#make sure beta hat function works for y x and betazero
beta_hat_func(y,x,beta_zero)
betahat_optimize<- optim(beta_zero, function (z) beta_hat_func(y,x,z))
beta.hat<- betahat_optimize $par
beta.hat
resid <- response - covariates%*%as.matrix(beta.hat)
sigma2.hat <- (1/df)*t(resid)%*%resid
resid
sigma2.hat
solve(t(covariates)%*%covariates)
# Estimate of the variance of the estimated beta from Eq. (6.2)
var.beta <- sigma2.hat*solve(t(covariates)%*%covariates)
t(covariates)%*%covariates
a = t(covariates)%*%covariates
solve(a)
solve(t(covariates)%*%covariates)
sigma2.hat*solve(t(covariates)%*%covariates)
solve(t(covariates)%*%covariates)
is(sigma2.hat)
# Estimate of the variance of the estimated beta from Eq. (6.2)
var.beta <- as.vector(sigma2.hat)*solve(t(covariates)%*%covariates)
var.beta
my_lm = function(response, covariates, alpha = 0.05) {
# Make sure data formats are appropriate
response <- as.vector(response)
covariates <- as.matrix(covariates)
# Define parameters
n <- length(response)
p <- dim(covariates)[2]
df <- n - p
# Estimate beta through optimization()
x= covariates
y= response
beta_zero<- NA
p<- dim(x)[2]
beta_zero[1] <- mean(y)
#continuing to fill in beta_zero
for (i in 2:p) {
beta_zero[i]<- cov(y,x[,i])/var(x[,i])
}
#make sure beta hat function works for y x and betazero
beta_hat_func(y,x,beta_zero)
betahat_optimize<- optim(beta_zero, function (z) beta_hat_func(y,x,z))
beta.hat<- betahat_optimize $par
# Estimate of the residual variance (sigma2) from Eq. (6.3)
# Compute residuals
resid <- response - covariates%*%as.matrix(beta.hat)
sigma2.hat <- (1/df)*t(resid)%*%resid
# Estimate of the variance of the estimated beta from Eq. (6.2)
var.beta <- as.vector(sigma2.hat)*solve(t(covariates)%*%covariates)
# Estimate of the confidence interval based on alpha
quant <- 1 - alpha/2
ci.beta <- c(beta.hat - qnorm(p = quant)*sqrt(var.beta), beta.hat +
qnorm(p = quant)*sqrt(var.beta))
# Return all estimated values
return(list(beta = beta.hat, sigma2 = sigma2.hat,
variance_beta = var.beta, ci = ci.beta))
}
my_lm(y,x)
t(covariates)%*%covariates
class_data <- read.csv("forestfires.csv")
#Function to minimize to achieve beta estimate
beta_hat_func = function(y, x, beta){
return((t(y-as.matrix(x)%*%beta))%*%(y-as.matrix(x)%*%beta))
}
#Test data (example is forestfires.csv)
y<- class_data[,"ISI"]
x<- class_data[,c("temp","wind")]
x<- cbind(1,x)
my_lm = function(response, covariates, alpha = 0.05) {
# Make sure data formats are appropriate
response <- as.vector(response)
covariates <- as.matrix(covariates)
# Define parameters
n <- length(response)
p <- dim(covariates)[2]
df <- n - p
# Estimate beta through optimization()
x= covariates
y= response
beta_zero<- NA
p<- dim(x)[2]
beta_zero[1] <- mean(y)
#continuing to fill in beta_zero
for (i in 2:p) {
beta_zero[i]<- cov(y,x[,i])/var(x[,i])
}
#make sure beta hat function works for y x and betazero
beta_hat_func(y,x,beta_zero)
betahat_optimize<- optim(beta_zero, function (z) beta_hat_func(y,x,z))
beta.hat<- betahat_optimize $par
# Estimate of the residual variance (sigma2) from Eq. (6.3)
# Compute residuals
resid <- response - covariates%*%as.matrix(beta.hat)
sigma2.hat <- (1/df)*t(resid)%*%resid
# Estimate of the variance of the estimated beta from Eq. (6.2)
var.beta <- as.vector(sigma2.hat)*solve(t(covariates)%*%covariates)
# Estimate of the confidence interval based on alpha
quant <- 1 - alpha/2
ci.beta <- c(beta.hat - qnorm(p = quant)*sqrt(var.beta), beta.hat +
qnorm(p = quant)*sqrt(var.beta))
# Return all estimated values
return(list(beta = beta.hat, sigma2 = sigma2.hat,
variance_beta = var.beta, ci = ci.beta))
}
my_lm(y,x)
my_lm = function(response, covariates, alpha = 0.05) {
# Make sure data formats are appropriate
response <- as.vector(response)
covariates <- as.matrix(covariates)
# Define parameters
n <- length(response)
p <- dim(covariates)[2]
df <- n - p
# Estimate beta through optimization()
x= covariates
y= response
beta_zero<- NA
p<- dim(x)[2]
beta_zero[1] <- mean(y)
#continuing to fill in beta_zero
for (i in 2:p) {
beta_zero[i]<- cov(y,x[,i])/var(x[,i])
}
#make sure beta hat function works for y x and betazero
beta_hat_func(y,x,beta_zero)
betahat_optimize<- optim(beta_zero, function (z) beta_hat_func(y,x,z))
beta.hat<- betahat_optimize $par
# Estimate of the residual variance (sigma2) from Eq. (6.3)
# Compute residuals
resid <- response - covariates%*%as.matrix(beta.hat)
sigma2.hat <- (1/df)*t(resid)%*%resid
# Estimate of the variance of the estimated beta from Eq. (6.2)
var.beta <- as.vector(sigma2.hat)*diag(solve(t(covariates)%*%covariates))
# Estimate of the confidence interval based on alpha
quant <- 1 - alpha/2
ci.beta <- c(beta.hat - qnorm(p = quant)*sqrt(var.beta), beta.hat +
qnorm(p = quant)*sqrt(var.beta))
# Return all estimated values
return(list(beta = beta.hat, sigma2 = sigma2.hat,
variance_beta = var.beta, ci = ci.beta))
}
my_lm(y,x)
